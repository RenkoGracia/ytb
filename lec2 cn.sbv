0:00:00.399,0:00:01.560
在之前的演讲中

0:00:01.560,0:00:07.359
我描述了各种关于系统演化树和系统演化网络的计算问题

0:00:07.359,0:00:17.920
今天我将向你们展示如何解决它们

0:00:20.720,0:00:25.840
我们先快速回忆一下上次演讲我们所学的内容

0:00:25.840,0:00:27.320
在上一次演讲中

0:00:27.320,0:00:31.199
我给出了系统演化树和系统演化网络的定义

0:00:31.199,0:00:34.719
然后解释了再分割树的概念

0:00:34.719,0:00:42.640
那就是一个可能非常复杂的系统演化网络中的潜在树

0:00:42.640,0:00:50.719
含有至少一个再分割树的系统演化网络被称为基于树的网络

0:00:50.719,0:00:58.320
然后我们看一下七个关于再分割树的计算问题

0:00:58.320,0:01:05.280
这些问题是决定问题，寻找问题，偏差量化问题

0:01:05.280,0:01:12.799
计数问题，列表问题，优化问题和前k个排名问题

0:01:12.799,0:01:15.840
在这次演讲中，我将重点讨论前六个问题

0:01:15.840,0:01:19.520
因为分析最后一个问题对于技巧要求过高

0:01:19.520,0:01:22.640
但是不管怎样，今天演讲的要点是

0:01:22.640,0:01:26.400
所有这些问题都可以被一个定理解决

0:01:26.400,0:01:31.520
这就是我说的系统演化网络的一个结构定理

0:01:31.520,0:01:33.159
这个定理非常有用

0:01:33.159,0:01:41.000
因为它作为一个普通的框架可以用统一的方式解决不同的问题

0:01:41.000,0:01:43.960
事实上我们今天后面会得知

0:01:43.960,0:01:51.840
这个定理引起了一套用于再分割树不同问题的快速算法的出现

0:01:52.479,0:01:55.479
类似于许多其他结构定理

0:01:55.479,0:01:58.360
包括有限分割群结构定理

0:01:58.360,0:02:01.119
它在下一个页面会展示

0:02:01.119,0:02:05.520
这个定理的陈述可以分为两个部分

0:02:05.520,0:02:13.360
首先它声明了构建所有有根二叉系统演化网络的最简结构块

0:02:13.360,0:02:16.239
我会在后面更详细地解释

0:02:16.239,0:02:23.120
它为有根二叉系统演化网络提供了一种唯一的规范分解

0:02:23.120,0:02:26.040
在这种规范分解的基础上

0:02:26.040,0:02:33.760
它以直积的形式描绘了所有再分割树集合的特点

0:02:33.920,0:02:36.319
为了给你们一个清晰的印象

0:02:36.319,0:02:43.200
我们在继续更多细节之前快速地复习一下抽象代数的基础知识

0:02:43.680,0:02:48.400
在各种数学分支中建立的许多结构定理里面

0:02:48.400,0:02:52.640
也许最著名的就是有限分割群的结构定理

0:02:52.640,0:02:58.480
这也被认为是所有有限阿贝群的根本定理

0:02:58.480,0:03:00.239
粗略地讲，它陈述了

0:03:00.239,0:03:01.239
每个有限阿贝群

0:03:01.239,0:03:06.640
都能被唯一地分解为许多有限循环群的一个直积

0:03:06.640,0:03:12.480
这和自然数的分解质因数十分相同

0:03:12.480,0:03:14.640
这个定理的应用包括

0:03:14.640,0:03:19.840
计算顺序n有多少个有限阿贝群的问题

0:03:19.840,0:03:24.400
比如说顺序144里有多少个阿贝群

0:03:24.400,0:03:32.879
数字144可以被分解为2^4*3^2

0:03:32.879,0:03:38.159
整数4有5种划分方法

0:03:38.159,0:03:41.920
而整数2有两种划分方法

0:03:41.920,0:03:43.920
因此所有可能的选择数量

0:03:43.920,0:03:51.000
或者说顺序144的阿贝群数量为5*2

0:03:51.000,0:03:53.439
当然，如果你想

0:03:53.439,0:03:56.560
你也可以列出所有可能的选择

0:03:56.560,0:03:59.920
即所有顺序144的阿贝群

0:03:59.920,0:04:03.120
正如你在这里能看见的

0:04:04.879,0:04:09.519
因此今天演讲的目标是展示

0:04:09.519,0:04:11.640
与我们内容相关的结构定理

0:04:11.640,0:04:18.160
以及理解它如何帮助我们解决我们之前看到的问题

0:04:20.000,0:04:24.759
好的，那么我们开始先看一下这个明显但重要的注意点

0:04:24.759,0:04:30.960
假设我们想构建一个基于树的网络n的一个再分割树

0:04:30.960,0:04:34.479
记住，任何再分割树都是一个n张成的树

0:04:34.479,0:04:39.520
因此顶点集合t一定与n的顶点集合完全相同

0:04:39.520,0:04:45.040
这意味着顶点集合的选择没有影响

0:04:45.040,0:04:50.160
因此唯一需要考虑的点就是选择哪个弧

0:04:50.160,0:04:54.560
显然如果我们任意地选择A（N）的一个子集s

0:04:54.560,0:04:59.600
那么s可能包括也可能不包括n的一个再分割树

0:04:59.600,0:05:03.840
如果我们仔细选择一个可接受的弧集合

0:05:03.840,0:05:06.960
那么我们能得到一个再分割树

0:05:06.960,0:05:09.000
如红线所示

0:05:09.000,0:05:13.600
但如果我们选择了一个错的（集合）如蓝线所示

0:05:13.600,0:05:18.240
得到的子图并不是n的再分割树

0:05:18.240,0:05:21.440
事实上它可能不是一个树

0:05:21.440,0:05:23.800
可能也没有一个唯一的根

0:05:23.800,0:05:28.160
或者有一个除了x以外的叶集合

0:05:29.000,0:05:32.440
然后很自然地出现了一个问题

0:05:32.440,0:05:40.320
决定s是否能引出n的一个再分割树的准则是什么

0:05:40.320,0:05:44.639
这个问题最初被francis和steel在他们的第一篇

0:05:44.639,0:05:47.240
关于基于树的网络的论文中被提起

0:05:47.240,0:05:51.560
他们描绘了当s引出再分割树的特征

0:05:51.560,0:05:56.080
方法是使用三个非常容易理解的条件

0:05:56.080,0:06:01.919
首先，根据左下方两个示意图的描述

0:06:01.919,0:06:07.039
如果n包含了一条达到入角度为1的顶点的弧

0:06:07.039,0:06:10.160
或者一个出角度为1的顶点的弧

0:06:10.160,0:06:12.319
我们必需选择它

0:06:12.319,0:06:17.440
这很容易看出

0:06:17.440,0:06:23.919
如果我们从s排除这样一条弧

0:06:24.319,0:06:28.319
那么s将引出一个含有不在x中的叶的子图或一个有额外根顶点的子图

0:06:29.120,0:06:35.600
第二，根据中间的描述

0:06:35.600,0:06:40.720
如果n有两条弧进入一个入角度为2的顶点

0:06:42.000,0:06:45.360
那�����我们必需选择其中的一条

0:06:45.360,0:06:48.880
因为我们想构建一个树

0:06:48.880,0:06:51.919
明显，我们不能同时选择它们

0:06:51.919,0:06:56.960
显然，我们也不能同时忽略它们

0:06:57.440,0:07:01.199
因为否则，我们将得到一个具有一个额外根的子图

0:07:01.199,0:07:07.639
第三，如右边所示

0:07:07.639,0:07:11.919
如果n有两条弧离开一个出角度为2的顶点

0:07:12.880,0:07:18.720
我们必需选择其中至少一个

0:07:18.720,0:07:22.080
满足这三个条件

0:07:22.080,0:07:27.199
是使s引出n的再分割树的一个充要条件

0:07:27.199,0:07:32.440
这意味着我们可以自动获得一个n的再分割树

0:07:32.440,0:07:34.720
方法是仅简单地选择x来满足这三个条件

0:07:34.720,0:07:40.160
从这里可以得到

0:07:40.160,0:07:45.280
在n的再分割树集合和n的弧集合之间

0:07:45.280,0:07:48.800
存在这一一对应的关系且满足这三个条件

0:07:48.800,0:07:54.080
我们把这样一个子集A称为可接受的

0:07:54.080,0:07:59.479
然后我们回到之前看到的问题

0:07:59.479,0:08:04.639
决定问题问的是是否存在一个可接受的弧集合

0:08:04.639,0:08:09.919
寻找问题要求找到一个可接受的集合

0:08:09.919,0:08:17.360
计数问题问的是有多少个可接受的弧集合

0:08:17.360,0:08:21.199
列表问题类似地要求生成所有可接受的A(N)的子集等等

0:08:21.199,0:08:30.160
为了解决这些问题，我现在介绍一个关键概念

0:08:30.160,0:08:36.000
那就是一个有根二叉系统演化x网络中的一个最大z形轨迹

0:08:36.000,0:08:42.240
直观上，n中的一个z形轨迹就是n的一个子图，使得

0:08:42.240,0:08:47.360
弧的序列呈现一种上下重复的移动

0:08:47.360,0:08:53.360
这里用绿线表示

0:08:53.360,0:08:57.600
更官方地说法是，n的一个子图集合会被称为z形轨迹

0:08:57.600,0:09:03.040
如果它的弧集合有一个排序使得

0:09:04.959,0:09:13.120
任意两个连续的弧有一个共同的头或尾

0:09:13.120,0:09:21.519
比如说，左边绿色的子图是这个系统演化网络中的一个z形轨迹

0:09:21.519,0:09:25.040
"因为如果我们把它的四条弧从左往右依次排序为a1,a2,a3,a4"

0:09:25.040,0:09:29.360
那么a1和a2共享尾部

0:09:29.600,0:09:32.720
a2和a3共享头部

0:09:32.720,0:09:39.360
a3和a4共享尾部

0:09:40.000,0:09:43.839
因此这里有它弧的这样一个排序

0:09:43.839,0:09:47.519
注意到右边红色子图的不同

0:09:47.519,0:09:52.560
这是一个普通的有向图

0:09:52.560,0:09:54.920
其中每条弧都指向相同方向

0:09:54.920,0:09:56.959
对于这个红色子图

0:09:56.959,0:10:00.240
并没有这样一种排序

0:10:00.240,0:10:04.240
所以它不是一个z形轨迹

0:10:04.240,0:10:08.680
另外我们会说z形轨迹是最大的

0:10:08.680,0:10:16.480
如果它不是网络里另一个严格更长的z形轨迹的一部分

0:10:16.480,0:10:24.160
比如说，下方的绿色子图是网络里一个z形轨迹，对吧

0:10:26.160,0:10:29.279
但它不是最大的，因为它是之前的z形轨迹的一个子图

0:10:29.279,0:10:37.839
相反，前一个（z形轨迹）是最大的

0:10:37.920,0:10:43.839
因为我们不能拓展它使其成为网络里一个更长的z形轨迹，所以它最大

0:10:43.839,0:10:46.959
好了，那么为什么最大z形轨迹的概念对我们如此重要呢？

0:10:46.959,0:10:53.440
因为它揭示了每个有根二叉系统演化网络被分解为其最大z形轨迹

0:10:53.440,0:10:56.560
是唯一确定的

0:10:56.560,0:10:59.320
你可以轻松验证

0:10:59.320,0:11:04.160
z形轨迹，即一个有根二叉系统演化网络

0:11:04.160,0:11:07.360
可以被分为仅有的四类

0:11:07.360,0:11:10.040
如右边所描述的

0:11:10.040,0:11:16.079
那些返回起始点的被称为王冠

0:11:18.240,0:11:27.040
那些不循环且呈现字母m形状的是m-栅栏

0:11:27.279,0:11:36.760
那些有奇数条弧的呈现字母n形状的是n-栅栏

0:11:36.760,0:11:42.160
而那些呈现字母w形状的是w-栅栏

0:11:42.160,0:11:49.200
所以比如说，这个左边的网络被分解为

0:11:49.839,0:11:53.880
一个具有两条弧的最大m-栅栏

0:11:53.880,0:11:58.959
和另一个具有两条弧的最大m-栅栏

0:11:58.959,0:12:04.320
一个具有六条弧的最大m-栅栏

0:12:10.200,0:12:14.480
一个具有两条弧的最大w-栅栏

0:12:14.720,0:12:18.959
一个具有三条弧的最大n-栅栏

0:12:19.040,0:12:25.760
和一个仅有一条弧的最大n-栅栏

0:12:25.760,0:12:28.880
顺便在一个二叉网络中

0:12:28.880,0:12:32.800
没有两个最大z形轨迹含有同一条弧

0:12:32.800,0:12:36.000
所以像我刚才陈述的那样

0:12:36.000,0:12:39.839
我们可以获得最大z形轨迹的集合

0:12:39.839,0:12:44.040
方法是仅访问网络的每条弧一次

0:12:44.040,0:12:51.200
所以接下来可知，最大z形轨迹分解可以在线性时间内计算

0:12:51.200,0:12:56.880
其数量级为关于输入网络大小的O(A（N））

0:12:57.440,0:13:00.800
总之，重要的事是

0:13:00.800,0:13:06.160
这样的分解总是由每个网络唯一确定

0:13:06.160,0:13:09.440
所以不管它多复杂

0:13:09.440,0:13:13.680
然后有根二叉系统演化网络可以规范地被分解为

0:13:13.680,0:13:18.079
这些简单片段组成的独特的集合

0:13:18.079,0:13:22.399
然后我们可以理解获得这个有用的引理

0:13:22.399,0:13:27.560
这和之前francis和steel建立的条件很相似

0:13:27.560,0:13:30.399
但不同点在于

0:13:30.399,0:13:35.839
我们不需要看网络的整个弧集合

0:13:36.560,0:13:42.240
一旦我们把网络分解为其独特的最大z形轨迹

0:13:42.240,0:13:50.240
所有我们要做的就是在每个最大z形轨迹里找到一个可接受的弧集合

0:13:50.240,0:13:54.320
然后把这些可接受的子集结合起来

0:13:54.320,0:13:54.959
好，那么这里有个例子

0:13:54.959,0:14:02.399
我现在解释如何寻找这个最大z形轨迹的��个��接受的弧集合

0:14:02.399,0:14:07.279
它由右边示意图的红线表示

0:14:08.560,0:14:14.360
假设我们已决定包含这条弧作为s的一个成员

0:14:14.360,0:14:18.399
在这个案例中，根据条件3

0:14:18.399,0:14:21.760
我们可以选择也可以不选择下一个

0:14:21.760,0:14:24.880
但我们这里选择它们

0:14:24.880,0:14:29.600
根据条件2，我们不能使用下一条弧

0:14:29.600,0:14:32.880
根据相同的理由，我们接下来必需选择这条弧

0:14:32.880,0:14:36.959
然后我们不能选择下一条

0:14:36.959,0:14:40.160
最后根据条件1或3

0:14:40.160,0:14:44.720
我们必需包含最后一条

0:14:44.720,0:14:53.279
这样我们就获得了这个最大z形轨迹中一个可接受的子集

0:14:55.680,0:14:56.839
用同样的方法

0:14:56.839,0:15:02.720
我们甚至可以清晰地表示所有可接受弧集合的家族

0:15:02.720,0:15:06.399
对于每种类型的最大z形轨迹

0:15:06.399,0:15:12.880
在i是一个王冠的案例中，你可以轻松得知

0:15:12.880,0:15:17.120
这里有两个可接受的弧集合

0:15:17.519,0:15:22.959
在zi是一个最大m-栅栏的案例中

0:15:22.959,0:15:29.440
可能选择的数量是集合i长度的一半

0:15:33.440,0:15:36.560
当zi是一个最大n-栅栏时

0:15:36.560,0:15:39.920
这里只有一个可接受的弧集合

0:15:39.920,0:15:46.160
最后在最大w-栅栏的案例中

0:15:46.160,0:15:49.440
没有任何其他可接受的弧集合

0:15:49.440,0:15:51.800
所以从这些观察中可以得出以下结论

0:15:51.800,0:15:55.279
如果n有一个最大w-栅栏

0:15:55.279,0:16:01.759
那么n没有再分割树

0:16:01.759,0:16:10.160
另一方面，如果n由其他类型的z形轨迹组成

0:16:10.160,0:16:12.519
那么简单地通过在每个最大z形轨迹中，选择一个可能的选项

0:16:12.519,0:16:18.240
然后通过这样做，我们可以创造/构建n的任意再分割树

0:16:18.240,0:16:21.920
因此可接受的弧集合的家族

0:16:21.920,0:16:26.399
或者说一个基于树的网络的所有再分割树的集合

0:16:26.399,0:16:31.920
可以被表达为所有可能选项的家族的一个直积

0:16:31.920,0:16:37.680
选项在每个最大z形轨迹中

0:16:37.680,0:16:41.519
这就是主要结果的第二部分

0:16:41.759,0:16:44.959
所以把两个结果放在一起

0:16:44.959,0:16:51.839
我们得到用于有根二叉系统演化网络的一个结构定理

0:16:55.040,0:17:00.880
从这个结构定理我们可以引出很多算法

0:17:02.160,0:17:03.359
作为预处理

0:17:03.359,0:17:11.439
每个算法都以把一个输入网络n分解为最大信号轨迹为开始

0:17:11.439,0:17:16.640
我之前解释过，这需要线性时间的数量级

0:17:16.880,0:17:24.319
重要的是，用一个直积的术语描述了再分割树的集合的特征后

0:17:24.319,0:17:29.480
我们可以确认构成再分割树数量的整数

0:17:29.480,0:17:32.200
就像分解质因数

0:17:32.200,0:17:38.320
所以我们可以计算数字alpha来表示再分割树的数量

0:17:38.320,0:17:43.360
只需要把可接受弧的集合数量相乘即可

0:17:43.360,0:17:46.720
在每个最大z形轨迹中

0:17:46.720,0:17:50.160
注意到这个算法可以同时解决

0:17:50.160,0:17:53.120
决定和计数问题

0:17:53.120,0:17:55.960
因为数字alpha非零

0:17:55.960,0:18:00.559
当且仅当网络是基于树的

0:18:00.559,0:18:03.679
在这个例子中我们可以得知

0:18:03.679,0:18:08.120
网络包含了一个最大w-栅栏z5

0:18:08.120,0:18:12.400
因此alpha-n等于0

0:18:12.480,0:18:14.360
当然，相反情况下

0:18:14.360,0:18:17.520
如果输入的网络不包含w-栅栏

0:18:17.520,0:18:19.320
你在左边可以看见

0:18:19.320,0:18:22.000
那么alpha就应该是一个正整数

0:18:22.000,0:18:26.160
它代表了这些基于树的网络的再分割树的数量

0:18:26.160,0:18:29.360
是这个网络

0:18:29.360,0:18:34.200
偏差量化问题的算法需要一些解释

0:18:34.200,0:18:36.480
但这很简单

0:18:36.480,0:18:40.559
它只是简单地计算有多少个最大w-栅栏

0:18:40.559,0:18:45.600
然后返回一个数量作为网络的偏差度量

0:18:45.600,0:18:47.640
这个算法是正确的

0:18:47.640,0:18:51.760
因为如果n包含被禁止的成分

0:18:51.760,0:18:54.960
也就是一个最大w-栅栏

0:18:54.960,0:19:03.600
那么我们可以通过附加一个额外的也到网络上来打破它（w-栅栏）

0:19:03.600,0:19:06.880
因此计算delta

0:19:06.880,0:19:10.400
其定义为把n转换为基于树的网络所需的

0:19:10.400,0:19:13.760
额外叶的最小数量

0:19:13.760,0:19:20.559
这和计算n中的最大w-栅栏的数量没什么区别

0:19:23.520,0:19:26.880
寻找问题也容易解决

0:19:26.880,0:19:32.919
给定一个基于树的网络，然后通过在每个最大z形轨迹中

0:19:32.919,0:19:38.640
挑选任意可接受的子集并把选中的弧组合起来

0:19:38.640,0:19:45.039
那么这些弧的集合就引出了n的一个再分割树

0:19:47.280,0:19:52.320
值得注意的是，优化问题可以在线性时间内被轻松解决

0:19:52.320,0:19:54.760
方法十分类似

0:19:54.760,0:20:01.240
这是因为在最大z形轨迹中，最佳弧集合的组合

0:20:01.240,0:20:05.000
会引出网络的最佳再分割树

0:20:05.000,0:20:06.000
也就是说

0:20:06.000,0:20:12.080
我们可以自动获得全局最优解仅仅依靠在每个z形轨迹中

0:20:12.080,0:20:15.919
收集一个最佳解决方案

0:20:15.919,0:20:22.720
所以我们知道没有必要去列出或检查所以可能的n的再分割树

0:20:22.720,0:20:25.760
这真的很棒

0:20:28.000,0:20:33.039
那么我们如何才能列出所有的再分割树呢？如果我们想这样做

0:20:33.039,0:20:37.520
列表问题和寻找问题类似

0:20:37.520,0:20:40.640
所有只要和我们之前做的一样就行了

0:20:40.640,0:20:45.679
算法在线性时间里输出了我们第一个解决方法

0:20:45.679,0:20:48.960
��和之前的做法一样

0:20:48.960,0:20:58.960
然后一个接一个地输出所有n的再分割树，t1，t2，t3

0:20:58.960,0:21:03.840
知道它（算法）列出所有再分割树

0:21:05.200,0:21:12.039
这里描述的算法属于列表算法中最高效的一类

0:21:12.039,0:21:16.400
因为它运行的延迟只有线性时间的数量级

0:21:16.400,0:21:21.919
也就是说这是一个具有如下三点性质的算法

0:21:22.480,0:21:28.400
首先，该算法可以在线性时间内输出一个快速的解法

0:21:28.400,0:21:32.240
线性时间与输入大小有关

0:21:32.960,0:21:38.480
其次，该算法可以一个接一个继续生成其他解法

0:21:38.480,0:21:45.320
这使得输出任意两个连续解法之间的时间

0:21:45.320,0:21:51.120
都被一个关于输入大小的线性函数限制

0:21:54.320,0:22:04.240
第三，该算法可以在关于输入大小的线性时间内再次决定是否终止

0:22:06.799,0:22:12.000
线性时间延迟列表算法相当好

0:22:12.000,0:22:20.400
因为它们的运行时间关于输入和输出大小都是线性的

0:22:23.760,0:22:29.520
好了，所以我们看到了从结构定理引出的各种算法

0:22:29.520,0:22:33.760
我将用一个使用了其中一个算法的

0:22:33.760,0:22:38.080
数据分析的解释来结束今天的演讲

0:22:38.080,0:22:46.120
那么想象一下，有一个生物学家正在研究八个不同物种的进化

0:22:46.120,0:22:51.120
而他想从一些生物数据中来重构进化树

0:22:51.120,0:22:58.320
他考虑了所有可能的进化路径

0:22:58.720,0:23:03.039
最后得到了如左边所示的一个网络

0:23:03.039,0:23:05.080
这个网络和树相差甚远

0:23:05.080,0:23:13.559
所以他来问你分析这样一个网络是否有意义

0:23:13.559,0:23:18.159
事实上这个网络复杂得像个蜂巢

0:23:18.159,0:23:23.840
但它还是基于树的网络对吧？

0:23:24.480,0:23:31.120
一旦你获得了最大z形轨迹分解

0:23:31.120,0:23:31.840
像这里描述的

0:23:31.840,0:23:42.960
你可以快速得知，通过手算，这个网络的再分割树的数量是5040

0:23:42.960,0:23:50.400
这个相当大的数字告诉我们这个网络有多复杂

0:23:50.400,0:23:59.840
但注意到，它还是远小于所有具有八个叶的系统演化树的数量

0:24:00.880,0:24:05.520
所以幸运的是，你可以对那个人总结说

0:24:05.520,0:24:08.880
虽然网络不完全是树状的

0:24:08.880,0:24:17.200
但它确实含有寻找正确的树的有意义的信息

0:24:17.200,0:24:19.320
好的，根据例子描述的

0:24:19.320,0:24:25.520
今天描述的算法预期可以在各种现实世界的设定里

0:24:25.520,0:24:33.840
找到很多的实际应用

0:24:50.000,0:24:52.320
好了，我的演讲到此结束

0:24:52.320,0:25:00.480
希望我的视频提供了一个关于离散数学生物学的好的介绍